# DogCat

# Enumeration

Executando um scanning com a ferramenta nmap

![Untitled](DogCat%2082649/Untitled.png)

A principio temos apenas as portas 80 (servidor web) e 22 (servidor ssh), então podemos começar a enumerar a parte web 

![Untitled](DogCat%2082649/Untitled%201.png)

Dentro do site, clicando na opção “A dog” 

![Untitled](DogCat%2082649/Untitled%202.png)

Inspecionando a imagem temos na url 

![Untitled](DogCat%2082649/Untitled%203.png)

Não temos acesso ao diretório /dogs/

![Untitled](DogCat%2082649/Untitled%204.png)

A mesma coisa para o /cats/ 

Voltando então a página inicial, porém dessa vez com o a ferramenta burp-suite
Clicando na mesma opção

![Untitled](DogCat%2082649/Untitled%205.png)

Mandei para a sessão de "repeater" do burp, para que eu possa executar e modificar diversas requisições com mais fácilidade  

![Untitled](DogCat%2082649/Untitled%206.png)

Ele aparentemente possui um filtro que verifica se possui as strings “cat” ou “dog”

![Untitled](DogCat%2082649/Untitled%207.png)

Colocando então a string dog na requisição 

![Untitled](DogCat%2082649/Untitled%208.png)

![Untitled](DogCat%2082649/Untitled%209.png)

Aparentemente só aceita arquivos .php, então podemos modificar a requisição para vermos um arquivo desse tipo, como o index.php, ou podemos ir modificando a requisição até burlarmos esse filtro também

Estamos querendo ler o código fonte da aplicação, que é em php, porém ao tentarmos ler ele, o sistema acaba executando ao invés de mostrar ele como um output, para bypassar esse problema podemos usar um php wrapper que encoda a saida em base64 assim ele não será executado

*php*://*filter*/*convert*.*base64*-*encode*/*resource*

![Untitled](DogCat%2082649/Untitled%2010.png)

![Untitled](DogCat%2082649/Untitled%2011.png)

traduzindo o output gerado anteriormente

![Untitled](DogCat%2082649/Untitled%2012.png)

# Exploitation

### LFI

A principio temos um LFI (Local File Inclusion) podemos ler arquivos do sistema, não conseguimos modicar e nem executar comandos (apesar de conseguirmos executar códigos php já presentes na máquina), apenas ler por enquanto.

Podemos agora analisa o código fonte da aplicação obtido na fase anterior e entender como ela funciona para burlar de forma mais precisa 

O parâmetro "ext" captura o final do arquivo, logo se por exemplo nós passarmos ele junto no final da requisição não teremos problema com o .php

![Untitled](DogCat%2082649/Untitled%2013.png)

![Untitled](DogCat%2082649/Untitled%2014.png)

Agora é questão de coletar informações do sistema, para encontrarmos uma forma de invadir ele

![Untitled](DogCat%2082649/Untitled%2015.png)

![Untitled](DogCat%2082649/Untitled%2016.png)

![Untitled](DogCat%2082649/Untitled%2017.png)

![Untitled](DogCat%2082649/Untitled%2018.png)

## Gain Access

### Log Poisoning

Temos uma forma de executar php nos arquivos, e pelo access.log podemos inserir algum dados ou melhor, códigos maliciosos através das nossas requisições

![Untitled](DogCat%2082649/Untitled%2019.png)

![Untitled](DogCat%2082649/Untitled%2020.png)

**Veja bem, esse tipo de falha não é explorada imediatamente, na verdade é bem provável que você demore um bom tempo tentando encontrar uma forma de explorar ela.**

![Untitled](DogCat%2082649/Untitled%2021.png)

![Untitled](DogCat%2082649/Untitled%2022.png)

A partir daqui conseguimos uma forma de executar comandos no sistema, logo podemos passar para uma fase que é “opcional” porém é extremamente útil, pois irá facilitar nossa vida

### Shell
Ganhar uma shell é ter acesso ao terminal do sistema, isso facilita muito as coisas pois assim temos de forma mais fácil um retorno dos comandos executados e do sistema em si

Usei a extensão [Hack-Tools](https://addons.mozilla.org/pt-BR/firefox/addon/hacktools/) para gerar um payload de reverse shell em php e dentro do burp utilizei a opção de url encode 

Nesse [site](https://github.com/swisskyrepo/PayloadsAllTheThings) existe vários outros payload
![Untitled](DogCat%2082649/Untitled%2023.png)

![Untitled](DogCat%2082649/Untitled%2024.png)


Uma vez que consegui a shell eu particularmente gosto de torná-la mais robusta

![Untitled](DogCat%2082649/Untitled%2025.png)

# Privelege Escalation

Verificando os nosos privilegios (geralmente essa é a primeira coisa que eu faço no privilege escalation)
![Untitled](DogCat%2082649/Untitled%2026.png)

Bastou pesquisar um pouco na internet e usar o [GTFOBINS](https://gtfobins.github.io/)
![Untitled](DogCat%2082649/Untitled%2027.png)

## Docker Escaping

Aparentemente já somos root, porém estamos dentro de um ambiente docker, logo precisaremos sair dele para chegarmos na máquina real

Enumerando os outros diretórios para ver o que temos no ambiente
![Untitled](DogCat%2082649/Untitled%2028.png)

Verifique que temos permissão de escrita, e que provavelmente esse script roda em uma pasta compartilhada entre o root da máquina real e o ambiente docker

![Untitled](DogCat%2082649/Untitled%2029.png)

# Mitigations

LFI: Reforçar os mecanismos de segurança da entrada de dados da aplicação (por exemplo verificar a extensão do arquivo requisitado pelo usuário / aplicação, white-list de caracteres)

Log Poisoning: Desabilitar a execução automática de php de arquivos fora do diretório da aplicação

Sistema: Revisar os privilégios do usuário que roda a aplicação dentro do ambiente docker
